

Важни команди и изрази при МАСИВИ лекцията:


List<string> lsitOfStrings = new List<string>();

string[] arrayOfStrings = {"Pesho", Ivan", "...};

List<string> listOfStrings = new List<string>(arrayOfStrings);

foreasch (string str in arrayOfStrings)
{
	listOfStrings.Add(str);
}

//pechat sas razdelitel ", "
string numbersAsString = string.Join(", ", numbers); 
Console.WriteLine(numbersAsString);

ili
int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int[] copyNumbers = numbers;
numbers[5] = -1111;
Console.WriteLine(string.Join(", ", numbers));
Console.WriteLine(string.Join(", ", copyNumbers));

.Add  .Remove   .Capacity .Count   .Input  .RemoveAt(3)  pri List<>

int[] copyArray = array;

int[] copyArray = (int[])array.Clone();   

List<int> list = new List<int>(){1, 2, 3, 4, 5, 6, 7};
Console.WriteLine(string.Join(", ", list));
list.Insert(2, -1);
Console.WriteLine(string.Join(", ", list)); 

хватки с List<>
сортиране на елементите с  
List<int> list = new List<int>(){9, 8, 4, 3, 5, 7};
Console.WriteLine(string.Join(", ", list));
list.Sort();
Console.WriteLine(string.Join(", ", list));

Отгоре добавя един метод
using System.Linq;
	този неймспейс дава страшно много методи. 
Копиране на масиви
int[] cloneAtrray = (int[])array.Clone();//metoda .Clone изкарва Object,
	затова е закължително кастването с (int[]) отпред!!!
	Подобно кастване се прави за преминаване към данни от съответния тип, след като операцията е
		изкарала данни от друг тип. Тогава няма да даде грешка!.
Копирането при List е различно:
List<int> copyList = new List<int>(list);


Сортиране на масиви
public class SortingArrays
{
    private static void Main()
    {
        int[] numbers = { 1, 2, 5, 10, 11 };

        Array.Sort(numbers, new NumbersComparer());

        Console.WriteLine("Numbers sorted by modul 5");
        foreach (int number in numbers)
        {
            Console.WriteLine(number);
        }

        Console.WriteLine();

        Array.Sort(numbers, (x, y) => (y % 6).CompareTo(x % 6));

        Console.WriteLine("Numbers sorted descending:");
        foreach (int number in numbers)
        {
            Console.WriteLine(number);
        }

        Console.WriteLine();

        string[] students = { "Doncho Minkov", "Nikolay Kostov", "Ivaylo Kenov", "Evlogi Hristov" };
        Array.Sort(students, new StudentsComparer());
        foreach (string student in students)
        {
            Console.WriteLine(student);
        }
    }

    private class NumbersComparer : IComparer<int>
    {
        public int Compare(int x, int y)
        {
            return (x % 5).CompareTo(y % 5);
        }
    }

    private class StudentsComparer : IComparer<string>
    {
        public int Compare(string student1, string student2)
        {
            var lastName1 = student1.Substring(student1.IndexOf(' ') + 1);
            var lastName2 = student2.Substring(student2.IndexOf(' ') + 1);
            return lastName1.CompareTo(lastName2);
        }
    }
}

Методи (функции, с и без параметри)

Всеки метод има име, с което се извиква и описва неговата цел. Декларират се в class. Main() е също метод като другите. 
static - методът може да се извиква от всеки друг метод, статичен или не.
void - методът не връща някакъв резултат. Т.е. извършва действие при извикването си, но не връща резултат. 
Могат да се извикват от всеки друг метод, вкюлчително и от себе си(подобно на рекурсия).
 
Лекция Методи - Ивайло - важни моменти: 
За да влезем за дебъгване в метод, натискаме F11. И тогава по брейкпойнтите минава по метода.Тогава може и с F10 вътре в метода.
Важно!!! В курса Arhive-Програмиране-2013/2014-Структури данни и алгоритми-Рекурсия - лекция, задачи и упражнения за рекурсия!!!

Обръщане на числа (като масив от цифри или стринг) или стрингове:  string number;  
	return string.Join("", number.ToCharArray().Reverse());   иначе:
	char[] charA = number.ToChararray(); string.Join("", charA.Reverse();)







Използване на класове и обекти

При "." след обекта в списъка - "ключетата" са състояния; "кубчетата" са методи или поведения;
Класът представлява шаблон за създаване на обекти със сходни характеристики. style for objects creation Класът дава структурата, която трябва да има всеки обект. Самите обекти казват какви са самите стойности. Класът дефинира мрежа от атрибути: променливи и свойства, които поддържат тяхното състояние и поведение. Класът дефинира всички методи и типове данни, които дадения обект има и може да прави. 
F12 - върху обекта сме и натискаме този клавиш - праща ни там, където е написан обекта. Примерно може да е преди стотици редове код. И това работи за всичко - за променливи, методи класове и т.н. Отиваме там, където е описано даденото нещо, което търсим. 
Property-s - появяват се като ключета след въвеждане на "." Пропертито описва текущото състояние на даден обект. 
Методите описват някакво поведение на обекта. Конструкторите - извикват се при new DateTime() например. Дават правилата при създаване на нова инстанция на класа. Всеки клас може да има няколко конструктора, по които можем да създаваме даден обект. Конструктора е като имаме някакъв шаблон, ние да укажем през конструктора как искаме да ни се създават отделните обекти. Като отидем между скобите () можем да видим всички възможни видове конструктори, които същестувват за този клас.  
Property-та са неща които ни връщат някаква стойност, пазят различна информация. Методите са нещо, което извършва действие - върши работа, изразява поведението на обекта. Последното са конструкторите - това е начинът по който създаваме об екти. Всеки клас има поне 1 понскрукто. Може да има и няколко. 
Примери за класове (или структури): System.Console., System.String(), System.In32(), System.Array, System.Math, System.Random, System.DateTime, System.Collections.Generic.List<T>, 

Полетата са нещо, което се съдържа в класа, но е е видимо за публичния свят. Приличат на Propertyes. Публичните неща (методите) се виждат като "кубче" след въвеждане на "." след инстанцията. А всичко останало, което не се вижда, са полета. Те съдържат отново информация. Всяко едно Property или поле (field) е глобално за целия клас. Ако например static int number = 5 се декларира отгоре след отварящите скоби на класа и ще работи във всички методи. Понеже е static е достъпно отвсякъде в рамките на класа. По този начин сме дегларирали някакво поле, което има някаква стойност=5 от тип int. Така тази променлива number е глобална за целия клас. По този начин отгоре в класа можем да си сетнем всички променливи, които ни трябват да използваме в класа и не се налага да ги пишем поотделно в различните методи. Освен това така ще сме сигурни, че няма да има променлива със същото име и да се чудим после какво става. Тези поленца пазят стойност, но не са публични. Самите полета и пропертита могат да бъдат константни и променливи.   
	const int number =5; - записан е като константа и по-нататък не може да бъде променян. Нямаме вече: number = 10;
	Същото важи и ако това е глобална променлива. Вместо static сме сложили const.  Примери за такива константи са int.MinValue, int.MaxValue, String.Empty. Всички неща, които има даден обект се достъпват с "." след инстанцията на обекта. 
	Пропертитата е това, което може да се вижда и да се използва от даден обект. 
	Ако имаме клас Student, полето firstName трябва да е public, за да можем да го използваме. 
	Всяко едно проперти има т.нар. get for reading their value and set to changing their value. 
	Developer-a определя дали дадена стойност може да се записва/променя или не. Много пъти може само да се чете, но не и set.
	Друг случай е когато не можем да четем, но можем да записваме - при пароли напр. и правене на акаунти. 
Смяна на цвета на конзолата - Console.BackgroundColor = ConsoleColor. и можем да избираме цвят за бекграунда на текста. 
	Как се вземат всички методи и пропертита - пишем променливата, пишем "." и те излизат. Пропертито пази текущото състояние. Пропертитата биват read only, write only and (read and write) с get и set. 
	Всяко нещо, което се съдържа в един клас може да бъде в инстанционен и в статичен вид. Инстанционен, означава че работи върху конкретния обет, конкр. инстанция.  
string text = "   Pesho    "; string anotherText ="  Ivan   " text.Trim()- чисти празните интервали Trim()работи върху конкретната инстанция.  т.е. той няма static отпред. static означава че работи глобално, върху целия клас.  Всички статични неща са общи. 
	Ако например напишем DataTime. излизат други неща, които са статични методи и свойства. Това са общите неща за целия клас DataTime. Console.WriteLine() напр. е статичен. и ако отворим с F12 ще видим отпред static. 
	Инстанционните неща работят върху крайните създадени обекти, а статичните - върху името на класа и се достъпват през името на класа, докато инстанционните се достъпват през името на конкретната инстанция/ създадения обект/.   
	Всеки клас си има инстанционни и статични методи. Инстанционните се извикват чрез конкретната инстанция, а статичните, чрез името на класа. Ако е статичен метода, в рамките на този клас може директно да се извиква, без името на класа. Докато ако методът е от друг клас, той се извиква през името на този клас. <Име на класа>.метод([параметри]). Пропертито се извиква без (). 
	Инстанционните методи се извикват през конкретен обект. 
	Конструкторите са специални методи, които се използват за сетване на първоначалните стойности на полетата в обекта. Като се напише new извикваме конструктор. char[] symbols = {'a', 'b', 'c'}; string text = new string(symbls); cw(); 
	Важно!!! За да работи text.Reverse().ToArray(); отгоре в дефинициите добавя: using System.Linq; но иска и .ToArray();
По различен начин създаваме някакъв обект, в зависимост от неговите конструктори (различни видове и ред на параметрите). 	
Промерно: int[] numbersArray() = new int[5]; numbersArray[1] = 15; List<int> numbers = new List<int>(numbersArray), т.е. прави ми лист от даден масив. Random randomGenerator = new Random(); randomGenerator.Next(101) - дава случайно число от 0 до 100. Може да укажем и долна граница: randomGenerator.Next(minValue, maxValue+1); случайни числа от minValue до maxValue. За да бъдат наистина рандом числа, създаваме отгоре само един рандом генератор, и после даваме където ни трябва .Next(value); Създаването на рандом генератора трябва да е извън цикъла. 
	Enumerations - дава стойностите от предварително дефинирана мрежа от стойности. Може да даде само от тях. Енумерациите са типове, иито стойности са ограничени в предварително дефинирана мрежа от стойности. Примерно: дни от седмицата, месеци в годината
Примерно цветовете на конзолата е енумерация. Console.BackgroundColor = ConsoleColor. и можем да изберем само дадените цветове. Как да си създадем енумерация? Вместо думата class пишем enum примерно enum Color {} и т.н. все едно че правим клас. Ето така: 
enum Color
{
	Red,
	Yellow,
	Blue
}		И после: Color myColor = Color.Red;  //myColor  е една от тези три стойности. Това е енумерация. 
	Structures - подобни на на класовете. Те са value types - директно поддържат стойности. Класовете са референтен тип. Обикновено се използват за запазване на структури от данни без някаква функционалност. Могат да имат полета, пропертита и др. Не се препоръчва да имат методи. Пример на структура е System.DateTime - represents data and time; Структурите са стойностни типове. Т.е. те се създават наново (не като масивите) и стойността се пази. Т.е. това са обекти, които се държат като примитивни данни.  
	Namespaces - използват се за организиране на сорс кода в по-логичен и управляем начин. Могат да съдържат дефиниции на класове, структури, интерфейси и други типове и неймспейси. Могат да съдържат други namespaces. System contains Data namespace Името на Data e System.Data
	Отгоре с using..... казваме кое от къде искаме да го ползваме. Ако имаме наш неймспейс, но не е указан отгоре на друг неймспейс, не можем да го ползваме-подчертава. След като го вмъкнем с using... всичко се оправя. Иначе <namespace_name>.<class_n>
	За Random класа - винаги да имаме само една единствена инстанция на Random. И генерираме числа с .Next от нея. 
	using System.Text; позволява ни да правим StringBuilder; StringBuilder result = new StringBuilder(); result.Append("A") и т.н. накрая има string resultAsString = result.ToString();	
	Генериране на парола от 15 случайни символа:  2малки+2големи+число+3специални + до случаен номер запълнени от всички:
    class Program
    {
        private const string CapitalLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        private const string SmallLetters = "abcdefghijklmnopqrstuvwxyz";
        private const string Digits = "0123456789";
        private const string SpecialChars = "~!@#$%^&*()_+=`{}[]\\|':;.,/?<>";
        private const string AllChars = CapitalLetters + SmallLetters + Digits + SpecialChars;

        static Random rndGenerator = new Random();
        static void InsertRandomSymbols(int count, StringBuilder password, char[] symbols)
        {
            for (int i = 0; i < count; i++)
            {
                char symbol = symbols[rndGenerator.Next(0, symbols.Length)];
                int randomPosition = rndGenerator.Next(0, password.Length);
                password.Insert(randomPosition, symbol);
            }
        }
        static void Main(string[] args)
        {
            StringBuilder password = new StringBuilder();
            InsertRandomSymbols(2, password, CapitalLetters.ToCharArray());
            InsertRandomSymbols(2, password, SmallLetters.ToCharArray());
            InsertRandomSymbols(1, password, Digits.ToCharArray());
            InsertRandomSymbols(3, password, SpecialChars.ToCharArray());
            int count1 = rndGenerator.Next(0, 7);
            InsertRandomSymbols(count1, password, AllChars.ToCharArray());
            Console.WriteLine(password.ToString());
        }
    }
.Net Common Type System - дефинира всички типове данни, поддържани от .Net Framework; Primitive types, Classes, Structures, Arrays Etc.  Object Oriented by Design. Той е еднакъв за всички .Net езици: C#. BV.Net, J#, JScript.Net, 
CTS Type: Int32, Single, Boolean, Double, String, Object Абсолютно всичко е обект. Всеки обект има ToString(); Equals(), GetHashCode(); GetType();  Equals()- сравнява два обекта, които не знаем как да сравняваме, дали са на едно и също място в паметта 
object list = new List<int>(); var name = list.GetTipe().Name; Console.WriteLine(name); ше върне List.

Важно!! При DateTime temp = now.AddDays(i) - можем да правим нова дата като добавяме дни. 


Стрингове и текстообработка
Всеки стринг е read-only; При всяка операция върху стрингове се създава нов стринг с крайния резултат. Референтен тип, но се държи като приминивни данни. Стринговете са обекти, подобни на чар масив. Има String.Length. По индексатор може да се взема всяка отделна буквичка. Сравняване на стрингове: 
	"abc"CompareTo("abcd") - лексикографски сравнява;    Case-insensitive: 
int result = string.Compare(str1, str2, true); result==0 (//str1=str2); result<0 //str1 before str2; result > 0 //str1 after str2.
	Case-sensitive: string.Compare(str1, str2, false);  string.Compare("abc", "ABC", false) дава -1, т.е. "abc" е преди "ABC".
но интересни са случаите: string.Compare("BAC", "abc", false) //1, т.е. abc е първо; Сравнява като в речник, по азбучен ред, първо малки букви, после големи. Ако искаме лексикографски да сравним, трябва да сравняваме буква по буква. cw("pesho"=="gosho") Сравнява двата стринга //false; if(str1==str2) или if(str1.Equals(str2)) Тези сравнения са Case-sensitive; Pesho"=="pesho"//false
	Важно!!! Едната задача за изпита - от динамично оптимиране. Но се решават всяка по различен начин. 
        string[] texts = { "6", "2", "4", "-1", "3" };
        string minText = texts[0];
        for (int i = 1; i < texts.Length; i++)
        {
            if (string.Compare(minText, texts[i], false) > 0)
            {
                minText = texts[i];
            }
        }
	Console.WriteLine(minText);






















